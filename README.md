# REST API для системы бронирования билетов на сеансы в кинотеатре

Перед запуском убедитесь, что вы установили Node.js версии 12 или выше.

Для запуска сервера перейдите в папку с репозиторием, затем в каталог `backend` в папке репозитория, и выполните команду `npm run start`. Для остановки нажмите сочетание клавиш CTRL+C.

При запуске сервер автоматически очистит информацию о кинозалах, расписание киносеансов и все бронирования, а также сгенерирует новые кинозалы и новое расписание киносеансов из БД фильмов. Параметры генерации расписания киносеансов можно посмотреть и настроить в файле `backend/.env`.

Если вы не хотите, чтобы сервер очищал и создавал снова кинозалы и расписание при запуске, можно запустить его командой `npm run start -- no-generation` (обратите внимание на пробел после `--`).

Для первоначального наполнения базы данных фильмов (файла `backend/storage/movies.json`) можно выполнить одну из команд:
* `npm run generateDB` - для генерации БД фильмов из случайных данных;
* `npm run realMovies` - для наполнения БД реальными фильмами (порядка 40 кинопремьер декабря 2023 г. плюс ~15 фильмов из категории киноклассики).

Параметры генерации базы фильмов можно посмотреть и настроить в файле `backend/.env`.

После запуска сервера API будет доступен по пути `http://localhost:3000`, либо на другом порту, который вы указали в `.env`-файле.

## Методы API и формат запросов/ответов

Все методы API, требующие тела запроса, ожидают получить тело в виде JSON. Ответы всех методов также отдаются в виде JSON.

### Получение информации о кинозалах

* `GET /api/cinema/halls` - получить массив объектов "Кинозал".

Пример ответа сервера:
```json
[
  {
    "rows": 11,        // кол-во рядов
    "seatsInRow": 10   // кол-во мест в ряду
  },
  {
    "rows": 10,
    "seatsInRow": 11
  },
  {
    "rows": 12,
    "seatsInRow": 12
  }
]
```

Предполагается, что все кинозалы прямоугольные, нумерация рядов стартует от экрана кинотеатра, нумерация как рядов, так и мест везде начинается с 0.

Длина полученного массива - общее кол-во кинозалов (нумерация кинозалов везде также указывается, начиная с 0).

### Получение списка жанров фильмов в БД кинотеатра

* `GET /api/cinema/genres` - получить отсортированный по алфавиту массив жанров всех фильмов в БД кинотеатра (всех фильмов, не только тех, что есть в расписании киносеансов).

Пример ответа сервера:
```json
[
  "аниме",
  "биографический",
  "биография",
  "боевик",
  "детектив",
  // ...
]
```

### Получение расписания киносеансов

* `GET /api/cinema` - полное расписание кинотеатра;
* `GET /api/cinema/{date}` - расписание кинотеатра на дату `{date}`, которая должна быть передана в формате `ГГГГ-ММ-ДД` (пример: `GET /api/cinema/2023-11-18`).

Запрос расписания кинотеатра на дату вернёт объект "Расписание киносеансов на день", формат которого описан ниже. Запрос полного расписания вернёт массив таких объектов, по одному на каждую дату расписания, в порядке возрастания дат.

Формат объекта "Расписание киносеансов на день":
```json
{
	// дата/время открытия кинотеатра в дату расписания
	"startsAt": "2023-11-18T04:00:00.000Z",
	"date": "18.11.2023",    // дата расписания в формате ДД.ММ.ГГГГ
	"dateURL": "2023-11-18", // дата расписания в формате ГГГГ-ММ-ДД
	"movies": [              // массив фильмов в расписании на день
		{
			"title": "Мальчик и птица",                   // название фильма
			"id": "1b9601fe-45fa-473b-ae27-6bc9d38d81fe", // ID фильма
			...           // прочие св-ва объекта "Фильм" описаны ниже в README
			"shows": [    // массив киносеансов с этим фильмом
				{
					// дата/время начала киносеанса
					"startsAt": "2023-11-18T04:00:00.000Z",
					// дата/время окончания киносеанса
					"endsAt": "2023-11-18T06:05:00.000Z",
					// timestamp начала киносеанса (используется для сортировки)
					"startsAtTimestamp": 1700280000,
					// номер кинозала (нумерация начинается с 0)
					"hallIndex": 0,
					// уникальный ID киносеанса
					"id": "d122fa9d-8f87-4ae8-ab13-8166ad906e1a"
				},
				{
					...    // ещё киносеанс с фильмом "Мальчик и птица"
				}
			]
		},
		{
			"title": "Назад в будущее",                   // название фильма
			"id": "6d65d193-8309-4889-90b4-3d78934b80c2", // ID фильма
			...           // прочие св-ва объекта "Фильм" описаны ниже в README
			"shows": [    // массив киносеансов с этим фильмом
				{
					...   // ещё киносеанс с фильмом "Назад в будущее"
				}
			]
		}
	]
}
```

### Получение информации о фильме

* `GET /api/cinema/movie/{id}` - получить информацию о фильме с ID = `{id}`.

Пример ответа и формат объекта "Фильм":

```json
{
	// название фильма
	"title": "Назад в будущее",
	// название фильма в оригинале (для иностранных фильмов)
	"originalTitle": "Back to the Future",
	// год премьеры (число)
	"year": 1985,
	// продолжительность в минутах (число)
	"duration": 116,
	// возрастной рейтинг ("12+", "18+", может быть пустой: "")
	"ageRating": "6+",
	// рейтинг на IMDB (число, может быть null, если рейтинга IMDB ещё нет)
	"imdbRating": 8.5,
	// описание в виде текста (без html). Можно обернуть в тег <p></p>
	"description": "Легендарная комедия ...",
	// массив жанров фильма
	"genres": [
		"комедия",
		"приключения",
		"фантастика"
	],
	// массив стран-производителей фильма
	"countries": [
		"США"
	],
	// ссылка на картинку-обложку фильма
	// можно безопасно использовать в атрибуте src тега <img>
	"image": "/static/img/movies/50.jpg",
	// уникальный ID фильма
	"id": "6d65d193-8309-4889-90b4-3d78934b80c2"
}
```

### Получение информации о киносеансе

* `GET /api/cinema/show/{id}` - получить информацию о киносеансе с ID = `{id}`;
* `GET /api/cinema/show/{id}?booking_id={bookID}` - получить информацию о киносеансе с ID = `{id}`, передав ID своего бронирования `bookID` для данного киносеанса.

Пример ответа:
```json
{
	// дата/время начала киносеанса
	"startsAt": "2023-11-18T09:00:00.000Z",
	// дата/время окончания киносеанса
	"endsAt": "2023-11-18T10:56:00.000Z",
	// timestamp начала киносеанса (используется для сортировки)
	"startsAtTimestamp": 1700298000,
	// номер кинозала (нумерация начинается с 0)
	"hallIndex": 2,
	// уникальный ID киносеанса
	"id": "5547e2a5-57dd-435a-9c1d-8e9506668d20",
	// объект "Фильм" - формат см. в разделе выше
	"movie": {
		"title": "Назад в будущее", // название фильма
		...           // прочие св-ва объекта "Фильм" описаны выше в README
	},
	// Информация о бронированиях мест
	"booking": {
		// уникальный ID киносеанса
		"showID": "5547e2a5-57dd-435a-9c1d-8e9506668d20",
		// кол-во рядов в кинозале
		"rows": 12,
		// кол-во мест в ряду в кинозале
		"seatsInRow": 12,
		// двумерный массив ([rowNum][seatNum]) с информацией о бронированиях
		"bookings": [
			// бронирования мест в первом (index = 0) ряду
			[
				null,     // null - место никем не забронировано
				"booked", // "booked" - место кем-то забронировано
				"booked", // "booked" - место кем-то забронировано
				null,     // null - место никем не забронировано
				null,
				// место забронировано клиентом
				// (необходимо передать в запросе booking_id, именно он будет
				// отображаться вместо "booked")
				"d9173e78-2b47-4c12-8753-44eb9b99aacf",
				// место забронировано клиентом
				"d9173e78-2b47-4c12-8753-44eb9b99aacf",
				null,
				null,
				null,
				null,
				null
			],
			// бронирования мест во втором (index = 1) ряду
			[
				// ...
			],
			// ...
		]
	}
}
```

Каждый элемент двумерного массива `bookings` может иметь одно из трёх возможных значений:
* `null` - это место никем не забронировано;
* ID бронирования (пример: `"d9173e78-2b47-4c12-8753-44eb9b99aacf"`) - место забронировано клиентом, который передал ID бронирования в строке запроса;
* `"booked"` - место кем-то забронировано (ID бронирования скрыт).

### Создание бронирования

* `POST /api/cinema/booking/{id}` - создать бронирование для киносеанса с ID = `{id}`. В теле запроса должен быть передан массив со списком мест, которые необходимо забронировать. Формат тела запроса:

```json
[
	{
		"rowNum": 4,  // номер ряда (нумерация начинается с 0)
		"seatNum": 10 // номер места в ряду (нумерация начинается с 0)
	},
	{
		"rowNum": 4,
		"seatNum": 11
	}
]
```

Если бронирование успешно завершено, сервер присвоит бронированию уникальный ID и вернёт его в свойстве `bookingID` ответа. Пример ответа:

```json
{
	// уникальный ID киносеанса
	"showID": "5547e2a5-57dd-435a-9c1d-8e9506668d20",
	// кол-во рядов в кинозале
	"rows": 12,
	// кол-во мест в ряду в кинозале
	"seatsInRow": 12,
	// ID только что созданного бронирования
	"bookingID": "575c58e0-8a2b-4b3b-8994-61eec9e7451a",
	// двумерный массив ([rowNum][seatNum]) с информацией о бронированиях
	// формат массива описан в разделе выше
	"bookings": [
		// ...
	]
}
```

Если бронирование не удалось совершить, сервер вернёт ошибку 422, а в свойстве `errorMsg` будет текст ошибки, объясняющей, что пошло нет так. Примеры:

```json
{
	"showID": "5547e2a5-57dd-435a-9c1d-8e9506668d20",
	"rows": 12,
	"seatsInRow": 12,
	"bookings": [
		// ...
	],
	"errorMsg": "Как минимум одно из выбранных мест уже забронировано!"
}
```
```json
{
	"showID": "5547e2a5-57dd-435a-9c1d-8e9506668d20",
	"rows": 12,
	"seatsInRow": 12,
	"bookings": [
		// ...
	],
	"errorMsg": "Неверный номер ряда и/или места для данного кинозала!"
}
```

### Обновление списка мест бронирования

* `PATCH /api/cinema/booking/{id}` - обновить бронирование с ID = `{id}`. В теле запроса должен быть передан массив со списком мест, которые необходимо забронировать.

***Важно:*** места, не переданные в теле запроса, будут освобождены (исключены из брони с указанным ID).

Формат тела запроса:

```json
[
	{
		"rowNum": 4,  // номер ряда (нумерация начинается с 0)
		"seatNum": 10 // номер места в ряду (нумерация начинается с 0)
	},
	{
		"rowNum": 4,
		"seatNum": 11
	}
]
```

Если обновление бронирования успешно завершено, сервер вернёт код 200, и объект со свойством `bookings`, содержащим двумерный массив с актуальной информацией о бронях для соотв. киносеанса. Пример ответа:

```json
{
	// уникальный ID киносеанса
	"showID": "5547e2a5-57dd-435a-9c1d-8e9506668d20",
	// кол-во рядов в кинозале
	"rows": 12,
	// кол-во мест в ряду в кинозале
	"seatsInRow": 12,
	// ID бронирования
	"bookingID": "575c58e0-8a2b-4b3b-8994-61eec9e7451a",
	// двумерный массив ([rowNum][seatNum]) с информацией о бронированиях
	// формат массива описан в разделе выше
	"bookings": [
		// ...
	]
}
```

Если бронирование не удалось обновить, сервер вернёт ошибку 422, а в свойстве `errorMsg` будет текст ошибки, объясняющей, что пошло нет так. Примеры:

```json
{
	"showID": "5547e2a5-57dd-435a-9c1d-8e9506668d20",
	"rows": 12,
	"seatsInRow": 12,
	"bookings": [
		// ...
	],
	"errorMsg": "Как минимум одно из выбранных мест уже забронировано!"
}
```
```json
{
	"showID": "5547e2a5-57dd-435a-9c1d-8e9506668d20",
	"rows": 12,
	"seatsInRow": 12,
	"bookings": [
		// ...
	],
	"errorMsg": "Неверный номер ряда и/или места для данного кинозала!"
}
```

Если бронирование с указанным ID не было найдено, сервер вернёт ошибку 404.

### Удаление бронирования

* `DELETE /api/cinema/booking/{id}` - удалить бронирование с ID = `{id}`.

Если бронирование успешно удалено, сервер обновит массив `bookings` для соотв. киносеанса и вернёт его в составе ответа. Пример ответа:

```json
{
	// уникальный ID киносеанса
	"showID": "5547e2a5-57dd-435a-9c1d-8e9506668d20",
	// кол-во рядов в кинозале
	"rows": 12,
	// кол-во мест в ряду в кинозале
	"seatsInRow": 12,
	// двумерный массив ([rowNum][seatNum]) с информацией о бронированиях
	// формат массива описан в разделе выше
	"bookings": [
		// ...
	]
}
```

Если бронирование с указанным ID не было найдено, сервер вернёт ошибку 404.


## Возможные статусы ответов

Ответ сервера может содержать один из статусов ответа:
* `200` - запрос обработан нормально;
* `201` - запрос на создание нового элемента успешно обработан;
* `404` - запрашиваемый элемент не найден в базе данных;
* `422` - объект, переданный в теле запроса, не прошёл проверку (например, такое бронирование невозможно создать). Тело ответа содержит свойство errorMsg с текстом ошибки;
* `500` - ошибка сервера.


## Тестирование API сервера

В папке `backend/tests` подготовлен набор файлов `.http` для отправки тестовых HTTP-запросов с помощью расширения VS Code "REST Client".

Вы можете использовать их для лучшего понимания нюансов работы API и формата запросов/ответов и для тестирования своего приложения.
